scanf_s("%f", &feet) {  // ввод данных в переменную feet
    %f -- ввод данных типа float
    &feet -- в переменную feet
        & -- оператор взятия адреса (где предшествует данный оператор, компилятор будет исп. вместо значения переменной её адрес)
} 
printf("%8.2f(Переменная a =  ) \n", a); -- вывод переменной в виде (2-символа после запятой)

\n -- перенос курсива на новую строку
\a -- звуковой сигнал
\b -- перемещение купсора на 1 позицию влево (удаляет эл который там был)
\f -- перевод страницы (очистка)
\r -- перемещение курсора в начало строки
\t -- перемещение курсора на 4 позиции вправо (tab)

идентафикатор - имена присваемой переменной функциям константам и даже типам данных исп. в программе, после объявления идентификатора можно на него ссылаться из любого места программы. Представляет собой последовательность символов произвольной длины, содержащую буквы цифры символы подчеркивания, но начинающиеся обязательно с буквы. (обычно не больше 31 символ, т.к компилятор не позволяет)
    языки c c++ чувствительны к регистру букв, а поэтому идентафикаторы Name и name различны
    
среди програмистов c++ есть соглашение начинать имя идентификатора с префикса его типа
    int iName
    float fName

не допустимы(т.к не начинаеться с буквы): 1st_year #social
не должно совпадать с именами ключевых слов(встроенные идентификаторы, каждому из которых соответствует определенное действие)
    _asm // для ставки кода assembler
    
стандартные типы данных
в c/c++ данные представляються одним из восьми базовых типов: char - символьный (занимает 8бит или 1байт) максимум 255 символов;
int - целочисленный от -32768 до 32767 (16бит);
float - числа с плавающей запятой одинарной точности от +- 4E до +38 (32бит);
double - вещественные числа двойной точности +-1,7E +308;
void - пустой тип, предгазначен для объявление функции которая не возвращает результата, когда функция не принимает аргумент (на пример: cls());
bool - логический тип (ток в c++) хранят ток значения двух констант TRUE FALSE (false=0 true = все остальные числа)
а также перечисление и указатели
(нет текстового типа)
    
перечисления представляються конечными наборами констант целочисленного типа 

указатели в отличии от переменных других типов не содержат сами данные, а содержат адреса памяти по которам данные храняться, символы

выражения на языках c/c++ записываються с помощию 26 строчных букв латинского алфавита, 10 цифр и спец символов + - */= , . _ ; : ? \" ' ~ | ! # $ & ( > { [ ^ @ (пробел)
    комбинация некоторых символов без пробела интерпретируеться как один символ
    
работа с переменнами типа char (лекция 4 visual studio)
    показывает как интерпритиповать символьное значение в целочисленном виде
    
    %x // требует вывести в шестнадцатеричном формате
    \" // позводяет вывести кавычку
    
    
ЛЕКЦИЯ 5
    модификаторы siqned и unsigned
    
    компилятор c/c++ позволяет для описания целочисленных и символьных переменных указывать модификатор unsigned таким образом он применяеться к типам char и типу int c его разновидностями наличие данного модификатора указывает что значение переменной должно интерпретироваться как беззнаковое число т.е старший бит числа явл битом данных, а не битом знака
        unsignet {
            char
            chort int long
        }
        
    signed(по умолчанию)  int -32768 до +32767
    unsigned              int 0 до 65535
 
числа с плавающей запятой (пример исп в visual studio)
        научный формат -- ровнее выводит данные
 
перечисления (тип данных) -- список именованных целочисленных констант называемыми перечислителями, переменные данного типа могут принимать значения одного из перечислителя (ссылаясь по имени enum)
        в примере создаеться перечисление типа tank {
                                                        //перечисляються перечислители 
                                                        EMPTY, USEABLE, FULL = 5, next
                                                    }
tank student;
tank instruction; -- tank - это тип созданный пользователем

все константы в перечислении имеют тип int и каждый из них автоматически присваиваеться значение по умолчанию если не указано какое-то значение (в нашем примере empty будет равен 0, а useable = 1, а full = 5 мы сами задаем, next = 6 по умолчанию)

объявив две переменные типа tank их можно исп. независимо друг от друга
    instructor = FULL
    
(используеться для работы с базами данных, чтоб манипулировать именными названиюми, а не цифрами )
    
тип bool относиться к семейсву целых чисел в c и c++ все условные выражение выдают логическое значение
    !true == false;
в с и с++ используються 2 квалификатора доступа coust и volatile (для обозначения неизм переменных, и переменных чьё значение может в любой момент измениться) иногда требуеться чтоб значение переменной не менялось во-время выполнения всей программы (число пи)
    const float PI=3.14 // ограничит манипуляции с пи только однократной иницилизации числового значения
    
в с и с++ существует другой способ объявления констант (#define Name 10)
    
ключевое слово valitail что данная переменная может измениться в любой момент в результате выполнения внешних действий в не выполняемых программах, может пригодиться когда переменная обновляеться системными устройствами такими как таймер, после получения сигнала программа останавливаеться, и переменная получает другое значение

// посмотреть систему прерывания

Преобразование типов данных (лекция 6)
    использовали переменные ток одного типа, но часто бывают случаи когда в операции принимают участия переменные разных типов, называються смешенными, в языке с можно автоматически преобразовать переменные типа 
        fresult = fvalue * ivalue; -- пример смешанной операции(компилятор автоматически выполнит преобразования типа, целочисленное значение ivalue - будет приведенно к вещественному типу умноженное на вещественное значение переменной fvalue и вещественный результат будет присвоен fresult) (сама переменная ivalue не изменяеться оставаясь целочисленной)
            
        автоматическое преобразование типов данных при выполнении смешанных операций проводиться в соответствии с иерархией типов, суть в том что с целью сохранения точности вычисления в смешанных операций значение разных типов приводиться к токому который имеет больший приоритет к иерархии
            приоритет: double, float, long, int, short
                если значение приобразуеться к типам имеющим меньшую позиц, потеря не происх
                ival1 = 3;
                ival2 = 4;
                fval = 7.0;
                fresult = fval + ival1/ival2; (ival1/ival2 -- результат 0, не смешанная операция  )
                
                если переменная ival2 будет записана как дробь то станет смешанной операцией и компилятор автомитически приведет ival1 к вещественному типу, результатом станет 0.75 и в сумме переменной fresult присвоит значение 7.75 (важно помнить что тип переменной находящийся слево от оператора присваивания определяет тип результата, чтоб в нашем примере не терялась точность нужно восп механизмом явного представления типа, служит оператор приведения типа, если гделибо в программе необходимо временно изм тип переменной нужно перед её именим ввести новый тип в круглых скобках 
                    fresult = fval + ival1/(float)ival2;)
                    
    Классы памяти (4 шт )
        auto, register, static, extern (может предшествовать объявлению переменных функций указывая компилятору как хранить переменные в памяти, и как получить доступ)
        определяют область видимости переменной, часть программы в пределах которой можно обратиться, на область видимости переменных влияет также место её объявлении, если объявление вне любой функции, то говорят о внешнем уровне объявления, а если в теле фенкции то это внутренне объявление.
                    
                внешний уровень -- являеться глобальной и поумолчанию класс памяти extern(ток если не находиться в функции)
                    (если в функции то по усолчанию auto)
                    можеи включать инициализацию или быть ссылкой на эту же переменную иницилизированную в другом месте, область видимости static распространяеться до конца файла обращение к такой переменной не может быть выше строки гле объявлена, объявляеться ток один раз, если в одном из файлов создана переменная с классом static то она может быть с таким же именем в любом другом файле программы (т.к доступны ток в пределах своего файла конфликта нет)
                    extern -- можно создать переменную доступную из любого файла программы, это может быть ссылка на переменную описанную в другом файле (делает возможным размещение ссылок до иницилизации)
                    пример исп extern(visual studio лекция 6)
                                                                            
        
        auto/register -- локальные (память выделяеться заново всякий раз, когда выполнение достигает блока в котором переменная объявлена и удаляеться по завершению выполнения блока)
        static/extern -- глобальные (память выделяеться один раз при запуске программы и удаляеться при завершении)
                    
    объявление переменной на внутреннем уровне 
        можно исп любой из 4 спецификаторов классов памяти, но по умолчанибю класс auto. явл локальными область видимости ограничена блоком в котором объявлены, спецификатор register указывает что переменную нужно сохранить в регистре процессора если это возможно в результате сокрашаеться время доступа к данным
        
        область видимости такая-же как у автоматических, в случае отсутсвия свободных регистров применяеться класс auto и она сохраняеться в обычн памяти (стандарт языка не позволяет запрашивать адрес переменной в с++ это ограничение снято и в данной ситуации регистр будет переведен в автоматическую и к ней будет применен оператор взятия адреса)
                    
        переменная объявленная на внутреннем уровне с static будиит хоть и глобальной, но доступ ток внутри блока, в отличии от auto значение сохраниться после выхода из блока
        
        локальная ток внутри блока удаляеться
        глобальные ток внутри блока не удаляеться
        
        extern исп для создания ссылки на переменную с таким же именем объявленную на внешнем уровне в любом исходном файле программы, если в блоке определяеться переменная с тем же именем, но без спецификатора extern то внешняя переменная становиться не доступной в данном блоке
        
ОПЕРАТОРЫ
    побитовые операторы(ток над целочисленными значениями, в отличии от логических сравниваеться не два числа целиком, а отдельные их биты);
        И (&) - записывает единицу если оба бита равны единицы; 
        ИЛИ (|) - записывает единицу если хотяб один равен единице (для установки отдельных битов числа);
        искл ИЛИ(^) - записывает результат если сравневыемыи биты различны (для вывода многоплановых изображений на экран, когда нужно чтоб задний план не перекрывал передний) 
        побитовое отрицание(инвентирует значение битов) (~) 
                    
    инкрементирование, декрементирование, вариант условного оператора, операторы комбинированного присваивания
    
    операторы сдвига {
        сдвиг влево  <<  -- сдвигает битовое значение целочисленной переменной указаной слево от оператора влево на количество битов указанной справа от оператора, младшие биты заполняються нулями, а старшие биты теряються
        сдвиг вправо >> -- также ток вправо
    }
    сдвиг беззнакового числа на одну позицию влево эквивалентен умнажению числа на 2
    сдвиг вправо - деление на 2
        
        
    инкрементирование и декрементирование
        для увеличения и уменьшения значения числа на 1 (a++(постриксная)/++a(префиксная)) если оператор явл единственным выражением, то место (до после) не имеет значения, в любом случае значение увеличиться на 1,
        в сложных нужно следить когда именно: при a++ сначала участвует в вычислениях, а потом значение увел; ++a сначала увеличиваеться, а потом участвует в вычислениях
        
Арифметические операторы
    существуют все стандартные арифм операторы (+ - * / %)
    % -- деление по модулю (вычисление остатка от целочисленного деления)
    var1 = var2 = var3 = 0; -- обнуляем все три переменные
комбинированный оператор присваивания {
    a+=b  то же самое  a = a+b 
    
    условие?выражение1:выражение2; -- если условие истино выполняеться первое выражение иначе второе
}

FOR WHILE DO/WHILE
    можно прервать с помощью break
    допускаеться принудительный переход на следуюшую итерацию с помощью continue
    не использовать счетчик в качестве переменной для хранения данных (i)
    первым выполняеться иницилизирующее выражение
    for (var i = 0; i>0, j>0; i--){ // может быть несколько счетчиков
        
    }
    
    do/while -- истиность проверяеться после интерации
    break -- вывести до того как условие станет ложным
    
    exit() -- EXIT_SUCCES/EXIT_FAILURE
    exit(status);

ФУНКЦИИ


    